# 202102


### 01

必须得完成一个自我要求, 就是自己的前端技术也必须达到专业化的程度.

### 02

---The Right Thing:

    1. ut-env: ootb-local
    2. ci-env: ci-local + ci-cloud + test-data
    3. grey-env: grey-cloud + prod-data
    4. prod-env: cloud + prod-data

    1. robots use inside-interface
    2. conf is always uniform
    3. conf is also data

### 03

有一行没一行地写, 竟也是一步一步地前进.
小孩子的电子玩具还在重复着龟兔赛跑的故事, 可这样的幼儿故事大人可真明白了?

### 04

有时候本不起眼的地方可能要费不少气力, 要有这种心理准备.

写程序本身有很多悖论. 有时候真像走迷宫的过程. 应该少说少用应该可以啊不应该啊.
这时候是说明你被感性一面带着走了.

不应该有特别难弄明白的bug, 否则的化就说明这事方式不对, 少做步骤了或者其它.

### 05

这天是有点凌乱.

回想这一天说说饮食吧.
编程是人和机器共同产生的活动.这时候人的饮食和计算机的供电单元是一样的作用.
要稳定

---不能吃得过饱. 过饱的人虚弱无力.
---不能出现明显的饥饿感. 明显的饥饿感很容易造成吃得过饱. 得随身带着点吃的.
---多吃水果, 使得水果成为饮食重要占比.

### 06

---ProHobby: 不写绝对路径.

有时候会质疑自己这么一行一行写程序所能产生的真正的现实作用.
想想python解释器和类库也是一点一滴积累起来的. 
积累的中间过程半成品也是没有什么现实作用.
当它的完成度很高的时候它的作用才成为现实.
所以
完成度 完成度 完成度
100%的完成度意味着超预期
50%的完成度意味着Nothing

### 07

直至纯粹

### 08

我发现我打印的日志有点ugly, 请改进...

我想把接口测试做成像接口文档一样可读, 这个想法似乎只是看着聪明.
我的目标应该是消除文档. 不否定文档的作用, 但是维护文档的项目不是最高效的, 可能只是必要的.
作为独立开发者, 我有一切可以利用的手段提高效率.
所以这里我的视线不应该落在自动化的文档上.
应该落在自动化执行测试上面.
代码应该是自文档化的.

### 09

---最高的自动化, 最少的代码

### 10

这天在春节放假前的波动中, 回看robot代码, 写复杂了.
复杂的代码给你一个明显的信号就是, 在你回看的时候, 你开始是真有点看不下去.
令人阅读愉悦的代码是最简单的代码.
这样的代码应该是每看一部分就告诉你一部分项目知识, 而不是给你一个新的疑团.

### 11

There`s a way to make it.
I should be better, much better.

### 12

And this is a war, baby. A war of myself.

### 13

我不仅是要构建完成系统, 更是在构建一种自己喜欢的和世界交互的方式.
我要构建的不是一个结果, 而是一种新的动态的机制.

优雅的设计是由极其简单的基础模式重复而成的.
这样的设计不仅仅是优雅更是稳健.

如果你想写的代码是"正"资产, Make every part of it simple.
当然所有极其简单的部分构成的整体是复杂的, 一种优美而稳健的复杂.

### 14

程序本质上是完成一系列处理.
它的设计问题是, 当需要做的处理任务变得复杂时, 如何正确地组织信息和协调执行.
处理任务会随着要求不同的时间条件触发, 根据不同的输入条件变化, 最后随着现实业务世界变化了也要进行变化
而变得异常复杂. 整个问题域看起来是繁杂凌乱的.

正确地执行处理任务是本质需求.
为了能有效保障正确性, 必须对信息数据组织和不同的处理动作协调进行有效的设计.
这就像是机械设计. 它的齿轮构建了机械世界的秩序.

寻求有效的设计的一种有效的方式就是寻求一种可重复的模式.
可重复的模式来自于...?

### 15

代码并不等于资产.
代码可以是资产、负债或者是熵.
我觉得函数范式是形成资产的一种有效方式.
