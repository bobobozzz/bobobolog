# 202101

### 01

夜以继日地工作. 
我信仰夜以继日地工作, 一步一步一步地构建完成.

妈妈带宝宝睡下了, 爸爸要来一杯咖啡, 开始用代码建设...

开发engine项目让我对入手新技术有了更好的驾驭.
对构建过程有了更好的驾驭.

有句话说: 成功需要一百个小步.
我想说, 你要耐心有章法地做好一万个小步的心理准备和坚持.
每一个下一小步都不太难, 一万个小步之后是他人无法跨越的门槛.

### 02

一个很大的困难是, 你要离开一个游戏, 独自进入另一个游戏.
而且这个游戏还是一个人的游戏.
能组织起一个人的游戏其实更为困难. 要有强大的"游戏组织能力".

夜跑回来继续...

### 03

原来创造灵感和驱动力弱, 很大一部分来自于能力弱.
react native给我赋能之后, 感觉到了更强的创造动力.
所以我要持续给自己赋能, 从给自己赋能作为每一步的起点.

还是可以说比较有进展. 去夜跑吧, 需要调整一下状态.

### 04

engine项目的上一个目标刚完成, 下一个目标还有时间.
但是要保持持续推进, 哪怕是一点点, 否则再启动就会很困难.
请启动惯性, 利用惯性, 保持惯性.

刚给宝宝洗完澡. 他要准备睡觉觉了. 我要准备继续在代码中前行.

engine在引入cutest进行c代码的单元测试. 当前遇到编译链接问题, 
是一个很好的问题. 我可以深入之前所不了解的gcc和make方面技术.
但这个问题今天走到了卡住得地方, 先暂停一下比较合适.

"桥"项目我现在是写页面还是写服务比较好... 好，页面.

好了好了， 休息会

### 05

五号了, 时间又慢又快.

Header Component终于有了. 没有的，都会有的.

Now, react native进行移动页面开发上手了, 下面关于页面只是时间问题.
因为有大量的细节.

### 06

我决定先做数据的展现, 再做数据输入相关的部分.
先基于静态数据模型展现, 再转换成服务接口, 再决定数据模型细节.

但是一个项目的推进过程完全不是机械化的(以上计划也是机械化的表达), 虽然软件系统是机械化的东西.
独立开发者的优势就是可以使用一种更灵活也更复杂进而可以更符合现实的开发方式或者说开发模型.

### 07

一个软件产品从0到上线使用, 解决某样问题. 就像是游戏"红色警戒"中的探索地图的过程.
这是一个多种方面频繁而复杂的交互推动来实现的. 这就是各种开发模型其实不如优秀的程序员好使的原因.
开发模型所描述和管理的过程都太简单, 是一种机械式的协作过程设定.

### 08

数学推导是沿着一条逻辑线前进.
一个软件产品的产生则是从许多维度推敲试探的结果.

人面对不可预期结果的时候行进就颠簸摆动,
而且这种震荡是不可控的,
所以我可以锚定在可预期的结果上.
可预期的结果就是我可以构建完成所有工作.

一旦出发就要到达, 否则沉没成本是一个不小的损失.

### 09

越写就会越发现, 工作量比想象的要多很多.

我可以把这想象为手工打造一辆汽车.
引擎的重要性, 车体工艺的重要性, 安全性的重要性... 对这些的考虑都可以形象化了.

不要想太多前后左右的东西, 专注于手头上的工作.

### 10

Now we need dynamic data.

资源是核心资产.
我必须给出一种方式, 保障优质资源的供给.
So robot.

### 11

I should be stronger by programming this, not weaker, I mean the hard work for my body.

我开始探索到了人脸识别技术了. 已经超过了我当初启动这个旅程时的想象.

Hard work is easy. 日复一日的艰辛工作是困难的.
我真的想度假旅游去.
我想我必须坚持使用一种武器：运动. 直至它成为我这一段旅程最主要的娱乐活动.

今天一晚上我计划让"robot"工作起来...

### 12

Programming robot is another different way.
我在设计和编码方面显现出了不流畅. 出手就是the ugly way, not graceful way.
So 发现一个不流畅的点. 让我们试着改进一下方式解决一下.

### 13

Supply Chain, It`s supply chain, Bro!

### 14

都是程序, 为什么这是robot呢? 我必须回答这个问题.
因为:

    1.拟人化特性及任务
    2.处理主动化和闭合化
    3.不直接接触用户请求处理

这些设计原因足够吗? 难道是Ugly Design?

### 15

我想到一个词: 反开发模式. 不知道别人有没有用过. 我的意思是指：
对独立开发者情况来说, 开发模式远不如流畅重要. 
因为工作量就在那里, 只要流畅没有卡顿就是有效推进. 要知道很多时候
弯路是工作量必不可少的组成部分.
书写的过程即思考的过程.
而vim又是为修改而生.

21:00 喝杯咖啡继续...

写robot的过程, 我好像开启了一种新的设计方式或者说是思路.
今晚完成了supply chain的设计思路和60%代码
周六写完所有代码
周日完成测试

### 16

---One Program and All Program

### 17

人其实绝大多数是类似数据的一种存在, 而公司等组织才是类似行为(method)的一种存在.
So I mean...

开发一个完整的产品和编写一个解决通常的算法问题是完全不同的两种问题.
前者是工程, 难度在于它是多维的问题.

关于流畅推进工作的问题, 我意识到这样一点:
明确划分出设计性编码这样一个阶段---把设计和编码融为一体.
而后是测试驱动编码, 这是应该最流畅最集中的编程部分.
注意: 必须要提高每次测试的执行速度. 这个很重要，很影响整体效率.
而后是集成测试.
像是制造一辆汽车, 如果不切分出阶段, 杂糅在一起的复杂度肯定会造成工作卡顿.

我们前进的主要问题是:
人同一时刻只能处理一维的逻辑, 如何将多维问题不停地转换为一维问题.

### 18

robot真的有点难写好不好.

在星巴克听到一行人在情绪激动地交涉.
我旁听到又是常见的软件开发问题, 矛盾点无外乎:

    1.交付的软件产品功能与约定存在差异
    2.认为开发工作量与价格不符
    3.交付延迟

这些问题一遍又一遍地出现.
我觉得本质原因在于软件开发不是传统的制造业.

---The great program and the great programer, they must be the One.

### 19

现在注意力转到servs开发.
内部服务调用真得非得需要再经过一层网络IO吗? 我在思考这个问题.
一个service, 特别是inside service, 应该是函数化的.
无论是通过web容器调用还是本地调用, 其输入输出应该是一致的.

### 20

再一次聚焦servs开发前, 需要思考清楚几个问题:

    1.鉴权选择如何去做.
    2.内部服务的rpc调用在一定场景下是否可以简化.

我需要加一个中间层. 能够灵活地转换本地调用和远程调用.

一个高完成度的设计是逐步弥合的.
具备难度的任务比起一个出色的解决方案来说更必须的是一个绝佳的改进反馈再改进的循环过程.

下一个问题是:
一个业务处理在开始之前拿到的参数完备程度问题, 特别是鉴权信息.
这个问题我们得随着开发进行解答.

---Program the code and answer the question.

下一个问题是:
预发布环境问题

预发布环境的目标应该是

    1.最大可能得模拟正式环境, 上线前做最准确的一次验证.
    2.便捷安全上线发布, 特别是防止一次修改上线不完整问题.
    3.当生产出现bug时, 进行重现分析的最佳环境.

我在想和灰度发布的关系.

---人生真正的旅行是语言性的.
